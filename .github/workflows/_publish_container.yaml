name: ~publish images from internal to public repo

on:
  workflow_call:
    inputs:
      SOURCE_IMAGE:
        type: string
        description: 'Source docker image:'
        required: true
      TARGET_IMAGE:
        type: string
        description: 'Target docker image (jax/t5x/etc.):'
        required: true
      TARGET_TAGS:
        type: string
        description: 'Target docker tags in docker/metadata-action format:'
        required: true
    outputs:
      DOCKER_TAGS:
        description: "Tags of the image published"
        value: ${{ jobs.publish.outputs.DOCKER_TAGS }}
      PACKAGE_URL:
        description: "Direct link to the GitHub package page for this image"
        value: ${{ jobs.publish.outputs.PACKAGE_URL }}

env:
  DOCKER_REGISTRY: 'ghcr.io/olupton'

jobs:
  publish:
    runs-on: ubuntu-22.04
    outputs:
      DOCKER_TAGS: ${{ steps.meta.outputs.tags }}
      PACKAGE_URL: ${{ steps.github-meta.package_url }}
    steps:
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ inputs.TARGET_IMAGE }}
          flavor: latest=false
          tags: ${{ inputs.TARGET_TAGS }}

      - name: Extract manifests from the source manifest list
        id: get-manifests
        shell: bash -x -e {0}
        run: |
          manifests=""
          for src_img in $(echo -e "${{ inputs.SOURCE_IMAGE }}" | tr '\n' ' '); do
            repo=$(echo $src_img | cut -d: -f1)
            media_type=$(docker manifest inspect $src_img | jq -r '.mediaType')
            case "$media_type" in
              
              # OCI image index
              "application/vnd.oci.image.index.v1+json")
                manifest=$(
                  docker manifest inspect ${src_img} |\
                  jq -r '.manifests[] | select(.platform.os != "unknown") | .digest' |\
                  xargs -I{} echo ${repo}@{} |\
                  tr '\n' ' '
                )
                ;;

              # Docker image manifest
              "application/vnd.docker.distribution.manifest.v2+json")
                manifest=${src_img}
                ;;

              *)
                echo "Unknown media type: $MEDIA_TYPE"
                exit 1
                ;;
            esac
            manifests="$manifests $manifest"
          done

          echo "manifests=$manifests" >> $GITHUB_OUTPUT

      - name: Create multi-arch images
        id: multi-arch
        shell: bash -x -e {0}
        run: |
          for tag in $(echo -e "${{ steps.meta.outputs.tags }}"); do
            docker buildx imagetools create --tag $tag ${{ steps.get-manifests.outputs.manifests }}
          done

      - name: Get GitHub package URL
        id: github-meta
        shell: bash -x -e {0}
        run: |
          # Get the Docker tag that we are going to lookup the package ID from,
          # and use in the generated URL. At the moment the two tags are just
          # X and X-YYYY-MM-DD, so taking the longest one makes sense.
          longest_cont=$(echo "${{ steps.meta.outputs.tags }}" | sort | tail -n 1)
          docker_tag=$(echo "${longest_cont}" | cut -d : -f 2)
          # TODO: do we need a delay or re-try loop in order for the package
          # to be available?
          # URL like https://github.com/NVIDIA/JAX-Toolbox/pkgs/container/jax/12
          package_url=$(curl \
              -H "Authorization: token ${{ github.token }}" \
              -H "Accept: application/vnd.github.v3+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/orgs/NVIDIA/packages/container/${{ inputs.TARGET_IMAGE }}/versions" \
            | jq -r ".[] | select(.metadata.container.tags[] == \"${docker_tag}\").html_url")
          echo "docker_tag=${docker_tag}" >> $GITHUB_OUTPUT
          echo "package_url=${package_url}?tag=${docker_tag}" >> $GITHUB_OUTPUT
          # base, jax, ...
          docker_tag_prefix=$(echo ${docker_tag} | cut -d - -f 1)
          markdown_file="${docker_tag_prefix}.md"
          echo "[${longest_cont}](${package_url}?tag=${docker_tag})" > "${markdown_file}"
          echo "markdown_file=${markdown_file}" >> $GITHUB_OUTPUT

      - name: Upload link file
        if: "!cancelled()"
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.TARGET_IMAGE }}-${{ steps.github-meta.outputs.docker-tag }}
          path: ${{ steps.github-meta.outputs.markdown_file }}

      # - name: Create single-arch images
      #   if: ${{ inputs.EXPOSE_SINGLE_ARCH_IMAGES }}
      #   shell: bash -x -e {0}
      #   run: |
      #     # Create new manifest list from extracted manifests
      #     for manifest in ${{ steps.get-manifests.outputs.manifests }}; do
      #       os=$(docker manifest inspect -v $manifest | jq -r '.Descriptor.platform.os')
      #       arch=$(docker manifest inspect -v $manifest | jq -r '.Descriptor.platform.architecture')
      #       for tag in $(echo "${{ steps.meta.outputs.tags }}"); do
      #         skopeo copy --format v2s2 docker://$manifest docker://$tag-${os}-${arch}
      #       done
      #     done
